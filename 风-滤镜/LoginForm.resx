<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="WindTimer.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <data name="CodeLabel.Text" xml:space="preserve">
    <value>//---------------------------------------------------------------------
//	This file is part of the Microsoft .NET	Framework SDK Code Samples.
// 
//	Copyright (C) Microsoft	Corporation.  All rights reserved.
// 
//This source code is intended only	as a supplement	to Microsoft
//Development Tools	and/or on-line documentation.  See these other
//materials	for	detailed information regarding Microsoft code samples.
// 
//THIS CODE	AND	INFORMATION	ARE	PROVIDED AS	IS WITHOUT WARRANTY	OF ANY
//KIND,	EITHER EXPRESSED OR	IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF	MERCHANTABILITY	AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//---------------------------------------------------------------------

using System;
using System.Net;
using System.Drawing;
using System.Collections;
using System.Globalization;
using System.Windows.Forms;
using System.ComponentModel;
using System.Net.NetworkInformation;

namespace Microsoft.Samples.NetworkInformation
{
    ///	&lt;summary&gt;
    ///	This form provides information pertaining to the network elements
    ///	on the current machine such	as network interfaces, IP addresses,
    ///	and	transmission statistics
    ///	&lt;/summary&gt;
    public partial class NetworkInformation : System.Windows.Forms.Form
    {
        ///	&lt;summary&gt;
        ///	Required designer variable.
        ///	&lt;/summary&gt;
        private System.ComponentModel.IContainer components = null;
        private NetworkInterface[] networkInterfaces = null;
        private NetworkInterface currentInterface = null;

        public NetworkInformation()
        {
            InitializeComponent();
        }

        private void NetworkInformation_Load(object sender, System.EventArgs e)
        {
            // Wire	up the NetworkAddressChanged events so we can get notified
            // when	an address change occurs on any of the network interfaces.
            // These changes occur when the interface changes operational
            // status (up/down) or a new interface is added. 
            NetworkChange.NetworkAddressChanged +=
                new NetworkAddressChangedEventHandler(
                NetworkChange_NetworkAddressChanged);
            NetworkChange.NetworkAvailabilityChanged +=
                new NetworkAvailabilityChangedEventHandler(
                NetworkChange_NetworkAvailabilityChanged);

            // Populate	the	global interfaces container	with the list of all
            // network interfaces.
            networkInterfaces = NetworkInterface.GetAllNetworkInterfaces();

            // Determine if	the	network	is available at	startup.
            UpdateNetworkAvailability(NetworkInterface.GetIsNetworkAvailable());

            // Update the information for the network interfaces.
            UpdateNetworkInformation();
        }

        // This	timer call updates information associated with the currently
        // selected	interface that is often	changing such as operational 
        // status, transfer	statistics,	and	speed.
        private void tmrUpdateInfo_Tick(object sender, System.EventArgs e)
        {
            UpdateNicStats();
        }

        private void UpdateNicStats()
        {
            // Get the IPv4	statistics for the currently selected interface.
            IPv4InterfaceStatistics ipStats = currentInterface.GetIPv4Statistics();

            NumberFormatInfo numberFormat = NumberFormatInfo.CurrentInfo;

            long bytesReceivedInKB = ipStats.BytesReceived / 1024;
            long bytesSentInKB = ipStats.BytesSent / 1024;

            this.speedTextLabel.Text = GetSpeedString(currentInterface.Speed);
            this.bytesReceivedTextLabel.Text =  bytesReceivedInKB.ToString("N0", numberFormat) + " KB";
            this.bytesSentTextLabel.Text = bytesSentInKB.ToString("N0", numberFormat) + " KB";

            this.operationalStatusTextLabel.Text = currentInterface.OperationalStatus.ToString();
            this.supportsMulticastTextLabel.Text = currentInterface.SupportsMulticast.ToString();
        }

        // Provide better formatting for some common speeds.
        static private string GetSpeedString(long speed)
        {
            switch (speed)
            {
                case 10000000:
                    return "10 MB";
                case 11000000:
                    return "11 MB";
                case 54000000:
                    return "54 MB";
                case 100000000:
                    return "100 MB";
                case 1000000000:
                    return "1 GB";
                default:
                    return speed.ToString(NumberFormatInfo.CurrentInfo);
            }
        }

        // Display the interface information that doesn't update so	often that
        // it should be	on the timer that fires	every 100 ms.  
        private void UpdateCurrentNicInformation()
        {
            // Set the DNS suffix if any exists
            IPInterfaceProperties ipProperties = currentInterface.GetIPProperties();
            this.dnsSuffixTextLabel.Text = ipProperties.DnsSuffix.ToString();

            // Display the IP address information associated with this
            // interface including anycast,	unicast, multicast,	DNS	servers,
            // WINS	servers, DHCP servers, and the gateway.
            this.addressListView.Items.Clear();
            IPAddressInformationCollection anycastInfo = ipProperties.AnycastAddresses;
            foreach (IPAddressInformation info in anycastInfo)
                InsertAddress(info.Address, "Anycast");
            UnicastIPAddressInformationCollection unicastInfo = ipProperties.UnicastAddresses;
            foreach (UnicastIPAddressInformation info in unicastInfo)
                InsertAddress(info.Address, "Unicast");
            MulticastIPAddressInformationCollection multicastInfo = ipProperties.MulticastAddresses;
            foreach (MulticastIPAddressInformation info in multicastInfo)
                InsertAddress(info.Address, "Multicast");
            GatewayIPAddressInformationCollection gatewayInfo = ipProperties.GatewayAddresses;
            foreach (GatewayIPAddressInformation info in gatewayInfo)
                InsertAddress(info.Address, "Gateway");

            IPAddressCollection ipAddresses = ipProperties.WinsServersAddresses;
            InsertAddresses(ipAddresses, "WINS Server");
            ipAddresses = ipProperties.DhcpServerAddresses;
            InsertAddresses(ipAddresses, "DHCP Server");
            ipAddresses = ipProperties.DnsAddresses;
            InsertAddresses(ipAddresses, "DNS Server");
        }

        // Used	for	inserting the IPAddress	information	into the listbox.
        private void InsertAddresses(IPAddressCollection ipAddresses, string addressType)
        {
            foreach (IPAddress ipAddress in ipAddresses)
                InsertAddress(ipAddress, addressType);
        }

        private void InsertAddress(IPAddress ipAddress, string addressType)
        {
            string[] listViewInformation = new string[2];
            listViewInformation[0] = ipAddress.ToString();
            listViewInformation[1] = addressType;

            ListViewItem item = new ListViewItem(listViewInformation);
            addressListView.Items.Add(item);
        }

        // Called on startup and whenever there	is a network change	event, this
        // method reloads the list of interfaces and sets the selection	to the
        // first one in	the	list.  The list	is reloaded	because	this event 
        // could have been fired as	a result of	an interface being removed from
        // the machine.
        private void UpdateNetworkInformation()
        {
            networkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
            this.networkInterfacesComboBox.Items.Clear();
            foreach (NetworkInterface networkInterface in networkInterfaces)
            {
                networkInterfacesComboBox.Items.Add(networkInterface.Description);
            }

            if (networkInterfaces.Length == 0)
            {
                this.networkInterfacesComboBox.Items.Add("No	NICs found on the machine");
            }
            else
            {
                currentInterface = networkInterfaces[0];
                UpdateCurrentNicInformation();
            }

            this.networkInterfacesComboBox.SelectedIndex = 0;

        }

        private void UpdateNetworkAvailability(bool isNetworkAvailable)
        {
            if (isNetworkAvailable)
            {
                this.networkAvailabilityTextLabel.Text = "At least one network interface is up.";
            }
            else
            {
                this.networkAvailabilityTextLabel.Text = "The network is not currently available.";
            }
        }

        private delegate void NetworkAddressChangedCallback();
        private delegate void NetworkAvailabilityCallback(bool isNetworkAvailable);

        // Update network interface	information	whenever an	address	changes.
        private void NetworkChange_NetworkAddressChanged(object sender, EventArgs e)
        {
            this.Invoke(new NetworkAddressChangedCallback(UpdateNetworkInformation));
        }

        // Update network availability.
        private void NetworkChange_NetworkAvailabilityChanged(object sender, NetworkAvailabilityEventArgs e)
        {
            this.Invoke(new NetworkAvailabilityCallback(UpdateNetworkAvailability), new object[1] { e.IsAvailable });
        }

        // Update current interface	information	whenever selection changes.
        private void OnSelectionChanged(object sender, System.EventArgs e)
        {
            currentInterface = networkInterfaces[networkInterfacesComboBox.SelectedIndex];
            UpdateCurrentNicInformation();
        }
    }
}

</value>
  </data>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>45</value>
  </metadata>
</root>